
// IE 10/11 polyfills
import 'isomorphic-fetch';
import polyfill from 'element-dataset';

import loadGoogleMapsApi from 'load-google-maps-api';

// css
import '../styles/main.scss';

import moment from 'moment';
import Mustache from 'mustache';
import fontawesome from '@fortawesome/fontawesome';
// import '@fortawesome/fontawesome-free-solid';
// import '@fortawesome/fontawesome-free-regular';
// import '@fortawesome/fontawesome-pro-light';
// import '@fortawesome/fontawesome-pro-regular';
import faPlus from '@fortawesome/fontawesome-free-solid/faPlus';
import faHome from '@fortawesome/fontawesome-free-solid/faHome';
import faCircle from '@fortawesome/fontawesome-free-solid/faCircle';

import faMapMarker from '@fortawesome/fontawesome-free-solid/faMapMarker';
import faMapMarkerAlt from '@fortawesome/fontawesome-free-solid/faMapMarkerAlt';

import faProMapMarker from '@fortawesome/fontawesome-pro-light/faMapMarker';
import faProMapMarkerAlt from '@fortawesome/fontawesome-pro-light/faMapMarkerAlt';

import driveIcon from '../custom-icons/ic_directions_drive_black_36px.svg';
import bikeIcon from '../custom-icons/ic_directions_bike_black_36px.svg';
import busIcon from '../custom-icons/ic_directions_bus_black_36px.svg';
import walkIcon from '../custom-icons/ic_directions_walk_black_36px.svg';

polyfill();

class Map{
	constructor() {
		const maindiv = document.getElementById('casadistance');
		const placeholderdiv = document.getElementById('casadistancePlaceholder');
		const showBtn = document.getElementById('casadistanceShowBtn');
		if (maindiv && showBtn) {
			showBtn.onclick = () => {
				console.log("click");
				if (showBtn) {
					showBtn.style.display = 'none';
				}
				if (placeholderdiv) {
					placeholderdiv.style.display = 'none';
				}
				maindiv.style.display = 'block';
				this.initMap();
			}
		}
		if (maindiv) {
			// pulling all presets from the config passed throug data properties
			this.showBtn = showBtn;
			this.maindiv = maindiv;
			this.placeholderdiv = placeholderdiv;
			this.lat = parseFloat(maindiv.dataset.lat) || 47.3769;
			this.lng = parseFloat(maindiv.dataset.lng) || 8.5417;
			this.zoom = parseInt(maindiv.dataset.zoom) || 12;
			this.googleMapsApiKey = maindiv.dataset.googleMapsApiKey || '';
			this.markerSize = maindiv.dataset.markerSize || "40px";
			this.markerIcon = maindiv.dataset.markerIcon || "faMapMarker";
			this.markerColor = maindiv.dataset.markerColor || "#000000";
			this.markerTitle = maindiv.dataset.markerTitle || "";
			this.markerPoiSize = maindiv.dataset.markerPoiSize || "20px";;
			this.markerPoiColor = maindiv.dataset.markerPoiColor || "#000000";
			this.markerPoiActiveColor = maindiv.dataset.markerPoiActiveColor || "#000000";
			this.markerPoiTextColor = maindiv.dataset.markerPoiTextColor || "#ffffff";;
			this.locale = maindiv.dataset.locale || "de";
			this.templateListitemContent = maindiv.dataset.templateListitemContent || '';
			this.templateDistanceResultItem = maindiv.dataset.templateDistanceResultItem || '';
			this.templateDistanceResultItemCloseBtnContent = maindiv.dataset.templateDistanceResultItemCloseBtnContent || '';
			this.distanceTimetableTitle = maindiv.dataset.distanceTimetableTitle || '';
			this.templateDistanceTimetableListTitle = maindiv.dataset.templateDistanceTimetableListTitle || '';
			this.templateDistanceTimetableItem = maindiv.dataset.templateDistanceTimetableItem || '';
			this.styles = maindiv.dataset.styles || '[]';
			this.loadMapImmediately = maindiv.dataset.loadMapImmediately === "true" ? true : false;

			// search types
			this.publicTransportTypes = ['bus_station', 'train_station', 'transit_station'];
			this.airportTypes = ['airport'];
			this.shoppingTypes = ['supermarket', 'grocery_or_supermarket', 'shopping_mall'];
			this.schoolTypes = ['school'];


			if(this.googleMapsApiKey === '') {
				let alertString = '';
				switch (this.locale) {
					case 'de':
						alertString = 'Achtung: Sie müssen einen persönlichen Google Api in der viewFile definieren mit "googleMapsApiKey" als data Property um Casadistanz nutzen zu können'
						break;
					case 'fr':
						alertString = 'Warning: You need to specify a personal Goolge Api Key in the viewFile with the data property "GoogleApiKey" to use Casadistance'
						break;
					case 'it':
						alertString = 'Warning: You need to specify a personal Goolge Api Key in the viewFile with the data property "GoogleApiKey" to use Casadistance'
						break;
					case 'en':
						alertString = 'Warning: You need to specify a personal Goolge Api Key in the viewFile with the data property "GoogleApiKey" to use Casadistance'
						break;
					default:
						alertString = 'Achtung: Sie müssen einen persönlichen Google Api in der viewFile definieren mit "googleMapsApiKey" als data Property um Casadistanz nutzen zu können'
						break;
				}
				return alert(alertString);
			}

			loadGoogleMapsApi({
				key: this.googleMapsApiKey,
				libraries: [
					'places',
					'geometry'
				],
				language: this.locale,
				v: 3.31
			}).then(() => {
				this.MarkerWithLabel = require('markerwithlabel')(google.maps);
				if (this.loadMapImmediately || !this.showBtn) {
					this.maindiv.style.display = 'block';
					this.initMap();
					if (this.showBtn) {
						this.showBtn.style.display = 'none';
					}
					if (this.placeholderdiv) {
						this.placeholderdiv.style.display = 'none';
					}
				}
			}).catch((error) => {
				console.log(error);
			});

			// set button functions
			/*document.getElementById('transit').addEventListener('click',(event)=>{
				this.transit();
			})
			document.getElementById('cycling').addEventListener('click',(event)=>{
				this.cycling();
			})*/
			/*document.getElementById('kindergarten').addEventListener('click',(event)=>{
				this.showNearBy(['childcare']);
			})*/
			
			document.getElementById('casadistanceShowSchools').addEventListener('click',(event)=>{
				this.deselectAllActiveItemsByClass('casadistance__menu__item--active');
				event.target.classList.add("casadistance__menu__item--active");
				this.showNearBy(this.schoolTypes, null, 2000);
			})
			/*document.getElementById('trainStation').addEventListener('click',(event)=>{
				this.showNearBy('train_station');
			})
			document.getElementById('busStation').addEventListener('click',(event)=>{
				this.showNearBy('bus_station');
			})
			document.getElementById('tramStation').addEventListener('click',(event)=>{
				this.showNearBy('tram_station');
			})*/
		
			document.getElementById('casadistanceShowPublicTransports').addEventListener('click',(event)=>{
				this.deselectAllActiveItemsByClass('casadistance__menu__item--active');
				event.target.classList.add("casadistance__menu__item--active");
				this.showNearBy(this.publicTransportTypes, null , 2000);
			});

			document.getElementById('casadistanceShowAirports').addEventListener('click',(event)=>{
				this.deselectAllActiveItemsByClass('casadistance__menu__item--active');
				event.target.classList.add("casadistance__menu__item--active");
				this.showNearBy(this.airportTypes, null, 50000); 
			})
			document.getElementById('casadistanceShowShopping').addEventListener('click',(event)=>{
				this.deselectAllActiveItemsByClass('casadistance__menu__item--active');
				event.target.classList.add("casadistance__menu__item--active");
				this.showNearBy(this.shoppingTypes, null, 2000);
			})
			
		}



	}

	deselectAllActiveItemsByClass(activeClass){
		const elements = document.getElementsByClassName(`${activeClass}`);
		for (var i = 0; i < elements.length; i++) {
			elements[i].classList.remove(`${activeClass}`); //second console output
		}
	}

	deselectMarkers(){
		this.markers.forEach((marker)=> {
			if(marker.type.indexOf('fa') === -1 && marker.labelClass === 'casadistance__marker casadistance__marker--active') {
				const iconColor = this.markerPoiColor;
				const iconType = faCircle;
				const iconSize = this.markerPoiSize;
				const fontawesomeLayer = this.createIconWithText(iconType, iconColor, marker.id);
				marker.setZIndex(0);
				marker.set('labelContent', fontawesomeLayer.html);
				marker.set('labelClass', 'casadistance__marker');
			}
		})
	}

	selectMarkerById(id){
		this.markers.forEach((marker)=> {
			if(marker.id === id) {
				const iconColor = this.markerPoiActiveColor;
				const iconType = faCircle;
				const iconSize = this.markerPoiSize;
				const fontawesomeLayer = this.createIconWithText(iconType, iconColor, id);
				marker.setZIndex(100);
				marker.set('labelContent', fontawesomeLayer.html);
				marker.set('labelClass', 'casadistance__marker casadistance__marker--active');

			}
		});
	}

	selectListItemById(id){
		const element = document.getElementById(id);
		const baseStyle = element.classList.item(0);
		element.classList.add(`${baseStyle}--active`);
	}

	deselectListItems(id){
		this.deselectAllActiveItemsByClass('casadistance__result__listitem--active');
	}
	
	initMap() {

		// Create a map object and specify the DOM element for display.
		this.map = new google.maps.Map(document.getElementById('casadistanceMap'), {
			center: {lat: this.lat, lng: this.lng},
			zoom: this.zoom,
			mapTypeControlOptions: {
				mapTypeIds: [
					'styled_map',
					google.maps.MapTypeId.HYBRID,
				],
			},
			labels: true,
		});
		
		this.markers = [];

		const styles = JSON.parse(this.styles); //user styles get loaded here

		const commonStyles = [
			{
				featureType: 'poi.business',
				stylers: [{visibility: 'off'}]
			},
			{
				featureType: 'transit',
				elementType: 'labels.icon',
				stylers: [{visibility: 'off'}]
			},
			{
				featureType: 'poi',
				elementType: 'labels',
				stylers: [{visibility: 'off'}]
			}
		];

		let name = '';
		switch (this.locale) {
			case 'de':
				name = 'Karte'
				break;
			case 'fr':
				name = 'Plan'
				break;
			case 'it':
				name = 'Mappa'
				break;
			case 'en':
				name = 'Map'
				break;
			default:
				name = 'Karte'
				break;
		}

		const customStyles = styles.concat(commonStyles);

		const styledMap = new google.maps.StyledMapType(customStyles, { name })
		this.map.mapTypes.set('styled_map', styledMap);
		this.map.setMapTypeId('styled_map');

		this.map.setOptions({ styles: commonStyles });

		// Property
		this.property = this.addPropertyMarker();
		


		
	}

	addPropertyMarker(){
		return this.renderMarker(
			{lat: this.lat, lng: this.lng}, 
			this.markerTitle, // title of property
			this.markerIcon,
			0
		);
	}

	// function for dynamic sorting
	compareValues(key, order='asc') {
	  return function(a, b) {
		if(!a.hasOwnProperty(key) || !b.hasOwnProperty(key)) {
		  // property doesn't exist on either object
			return 0; 
		}
      	
		// check for number and parse as such
		if(parseInt(a[key]) !== NaN){
			a[key] = parseInt(a[key])
		}
		if(parseInt(b[key]) !== NaN){
			b[key] = parseInt(b[key])
		}

		// if comparing strings uppercase
		const varA = (typeof a[key] === 'string') ? 
		  a[key].toUpperCase() : a[key];
		const varB = (typeof b[key] === 'string') ? 
		  b[key].toUpperCase() : b[key];

		let comparison = 0;
	    
		if (varA > varB) {
		  comparison = 1;
		} else if (varA < varB) {
		  comparison = -1;
		}
		return (
		  (order == 'desc') ? (comparison * -1) : comparison
		);
	  };
	}

	showNearBy(types, keyword, radius){
		radius = (typeof radius !== 'undefined' ? radius : 500)
		this.bounds = new google.maps.LatLngBounds();

		this.markers.forEach((marker)=>{
			marker.setMap(null);
		});

		this.markers = [];
		this.listing = [];
		
		// clean up DistanceContent that might still be open/rendered
		this.removeDistanceContent();
		
		// Property
		this.property = this.addPropertyMarker();

		this.bounds.extend(this.property.getPosition());
		this.markers.push(this.property);

		const resultList = document.getElementById('casadistanceResultList');
		this.maindiv.classList.add('casadistance--listactive');
		this.maindiv.classList.remove('casadistance--contentactive');
		resultList.classList.add('casadistance__result__list--active');
		while (resultList.firstChild) {
			resultList.removeChild(resultList.firstChild);
		}
		let count = 0;
		const forEachPromise = new Promise((resolve, reject) => {
			let combinedResults = [];
				types.forEach((type, index) => {
					this.nearBy(this.property.getPosition(), type, keyword, radius, (response, status, pagination) => {
						if (status === 'OK') {
							combinedResults = combinedResults.concat(response);
							/*if(pagination.hasNextPage){
								pagination.nextPage();
							}*/
						}
						// end?
						if(types.length-1 === index){
							resolve(combinedResults);
						}
					});
				})
		});

		Promise.all([forEachPromise]).then((values) => {
			// adding distance
			const combinedResults = values[0];
			const uniqueIdList = {};
			const uniqueNameList = {};
			const distanceResponse = combinedResults.filter((item,index) => {
				let lowerName = item.name.toLowerCase();
				let subtitle = item.formatted_address ? item.formatted_address : item.vicinity;
				if(!uniqueIdList[item.place_id] && !uniqueNameList[lowerName] && uniqueNameList[lowerName] !== subtitle){
					uniqueIdList[item.place_id] = lowerName;
					uniqueNameList[lowerName] = subtitle;
					// only relevant airports
					const relevantAirport = ['airport'].indexOf(item.types[0]) !== -1 && item.rating
					const notAirport = ['airport'].indexOf(item.types[0]) === -1;
					if ( relevantAirport || notAirport ){
						item.distance = google.maps.geometry.spherical.computeDistanceBetween(item.geometry.location, this.property.getPosition()).toFixed(0); 
						// anything in a 200km radius
						if(item.distance < 200000){
							return item;
						}
					}
				}
			})
			// sort
			const sortedResponse = distanceResponse.sort(this.compareValues('distance', 'asc'));

			// create items
			sortedResponse.forEach((item, index)=>{
				item.type = types[0];
				let listing = this.renderNearbyData(item, count+index);
				resultList.appendChild(listing);

			})
			this.map.fitBounds(this.bounds);
		})
		.catch((error) => {
			console.log(error);
		})

		


	}

	
	/*
	The standard Google Maps Geocoding API supports up to 100,000 requests daily. 
	A project will be restricted to the complimentary 2,500 per-day-limit until you enable billing on the project. 
	Once billing has been enabled, if you exceed 2,500 requests in a day, you will be billed at 
	$0.50 USD / 1000 additional requests, up to 100,000 daily.
	*/

	reverseGeoCode(location, type, cb){
		const geocoder = new google.maps.Geocoder();

		geocoder.geocode({
			location,
			componentRestrictions: {
				type: type,
			}
		}, cb);
	}

	createIconWithText(iconType, iconColor, text){
		return fontawesome.layer((push) => {
			push(fontawesome.icon(iconType, { 
					styles: {'color': iconColor}, 
				})
			)
			if(text) {
				push(fontawesome.text(text.toString(), {
						// don't do transform IE11 will destroy it
						// transform: {size: 10},
						styles: {'color': this.markerPoiTextColor, 'font-size': "14px"} 
					})
				)
			}

		});
	}

	renderMarker(position, title, type, index, property, id, vicinity){
		let iconColor,
			iconType,
			iconSize;
		switch(type) {
			case 'faMapMarker':
				iconColor = this.markerColor;
				iconType = faMapMarker;
				iconSize = this.markerSize;
				break;
			case 'faMapMarkerAlt':
				iconColor = this.markerColor;
				iconType = faMapMarkerAlt;
				iconSize = this.markerSize;
				break;
			case 'faProMapMarker':
				iconColor = this.markerColor;
				iconType = faProMapMarker;
				iconSize = this.markerSize;
				break;
			case 'faProMapMarkerAlt':
				iconColor = this.markerColor;
				iconType = faProMapMarkerAlt;
				iconSize = this.markerSize;
				break;
			/*case 'bus_station':
				iconColor = 'green';
				iconType = 'bus'
				break;
			case 'train_station':
				iconColor = 'green';
				iconType = 'train'
				break;
			case 'school':
				iconColor = 'green';
				iconType = 'graduation-cap';
				break;*/
			default:
				iconColor = this.markerPoiColor;
				iconType = faCircle;
				iconSize = this.markerPoiSize;
				break;
		}

		const fontawesomeLayer = this.createIconWithText(iconType, iconColor, index);
						

		const marker = new this.MarkerWithLabel({
			labelClass: 'casadistance__marker',
			position: position,
			icon: ' ',
			map: this.map,
			labelContent: fontawesomeLayer.html,
			labelAnchor: new google.maps.Point((parseInt(iconSize)/2), parseInt(iconSize)),
			labelStyle: {"font-size": iconSize, color: this.markerPoiTextColor}, // size of Label/Icon
			title: title,
			type: type,
			id: id
		});

		if (type !== this.markerIcon) {
			const locationTitle = title;
			const locationCoords = position;
			const locationType = type;
			google.maps.event.addListener(marker, 'click', (event) => { this.locationOnClickAction(event, locationTitle, locationCoords, locationType, property, index, vicinity)});
		}

		return marker;

	}

	locationOnMouseOutAction () {
		// deactivate all elements
		this.deselectMarkers();
		
	}

	locationOnMouseOverAction(event, id) {

		// deactivate all elements
		this.deselectMarkers();

		// activate elements
		this.selectMarkerById(id);
	}

	locationOnClickAction(event, locationTitle, locationCoords, locationType, property, id, vicinity) {

		// deactivate all elements
		this.deselectMarkers();
		this.deselectListItems();

		// activate elements
		this.selectMarkerById(id);
		this.selectListItemById(id);

		const element = event.target;

		this.maindiv.classList.add('casadistance--contentactive');

		// get Distances
		const contentCar = new Promise((resolve,reject) => {
			this.distance('DRIVING', locationCoords, property.getPosition(), (response, status) => {
				if (status === 'OK') {
					const timeElement = document.createElement('div');
					timeElement.innerHTML = this.renderDistanceData(`<img src='${driveIcon}'/>`,response, status);
					resolve(timeElement);
				} else {
					reject(status);
				}
			})
		});

		const contentTrain = new Promise((resolve,reject) => {
			this.distance('TRANSIT', locationCoords, property.getPosition(), (response, status) => {
				if (status === 'OK') {
					const timeElement = document.createElement('div');
					timeElement.innerHTML = this.renderDistanceData(`<img src='${busIcon}'/>`,response, status);
					resolve(timeElement);
				} else {
					reject(status);
				}
			})
		});

		const contentWalk = new Promise((resolve,reject) => {
			this.distance('WALKING', locationCoords, property.getPosition(), (response, status) => {
				if (status === 'OK') {
					const timeElement = document.createElement('div');
					timeElement.innerHTML = this.renderDistanceData(`<img src='${walkIcon}'/>`,response, status);
					resolve(timeElement);
				} else {
					reject(status);
				}
			})
		});
		
		const contentBike = new Promise((resolve,reject) => {
			this.distance('BICYCLING', locationCoords, property.getPosition(), (response, status) => {
				if (status === 'OK') {
					const timeElement = document.createElement('div');
					timeElement.innerHTML = this.renderDistanceData(`<img src='${bikeIcon}'/>`,response, status);
					resolve(timeElement);
				} else {
					reject(status);
				}
			})
		});

		// get Timetable for public transport on Switzerland
		let contentTimetable = '';
		if (this.publicTransportTypes.indexOf(locationType) !== -1 && vicinity === 'Switzerland') {
			
			contentTimetable = new Promise((resolve,reject) => {
				this.getTimeTable(locationTitle, locationCoords, (results) => {
					if (results){
						resolve(this.renderTimetableData(results));
					}
				});
			});
		}
		
		Promise.all([contentCar, contentTrain, contentWalk, contentBike, contentTimetable]).then((elements) => {
			// distanceContent is active
			const distanceContent = document.getElementById('casadistanceContent');
			distanceContent.classList.add('casadistance__result__content--active');

			distanceContent.addEventListener('mouseover', (event) => {this.locationOnMouseOverAction(event, id)});

			// listing is deactivated
			this.deselectAllActiveItemsByClass('casadistance__result__list--active');
					
			while (distanceContent.firstChild) {
				distanceContent.removeChild(distanceContent.firstChild);
			}

			//close btn
			const closebtn = document.createElement('button');
			closebtn.addEventListener('click', (event) => {
				this.removeDistanceContent();
				this.deselectMarkers();
				this.maindiv.classList.remove('casadistance--contentactive');
			});
			closebtn.innerHTML = Mustache.render(this.templateDistanceResultItemCloseBtnContent);
			closebtn.classList.add('casadistance__result__list__closebtn');

			const content = document.createElement('div');
			
			content.appendChild(closebtn);

			//title
			const title = document.createElement('h2');
			title.textContent = locationTitle;
			content.appendChild(title);

			//distances
			elements.forEach((element) => {
				if(element && element !== ''){
					content.appendChild(element);
				}
			})
			distanceContent.appendChild(content);
		})
		.catch((error) => {
			console.log(error);
		})
	}

	removeDistanceContent(){
		
		const content = document.getElementById('casadistanceContent');
		while (content.firstChild) {
			content.removeChild(content.firstChild);
		}

		// marker deselect
		this.deselectMarkers();


		this.deselectAllActiveItemsByClass('casadistance__result__content--active');
		this.deselectAllActiveItemsByClass('casadistance__result__listitem--active');

		const resultList = document.getElementById('casadistanceResultList');
		resultList.classList.add('casadistance__result__list--active');

	}

	transit() {
		
		if(this.transitLayer && this.transitLayer.getMap && this.transitLayer.getMap()) {
			this.transitLayer.setMap(null);
			
		} else {
			this.transitLayer = new google.maps.TransitLayer();
			this.transitLayer.setMap(this.map);
		}
	}

	cycling() {
		
		if(this.cyclingLayer && this.cyclingLayer.getMap && this.cyclingLayer.getMap()) {
			this.cyclingLayer.setMap(null);
		} else {
			this.cyclingLayer = new google.maps.BicyclingLayer();
			this.cyclingLayer.setMap(this.map);
		}
	}

	getTimeTable(station, latLng, cb){
		
		// http://sbb.xiala.net/
		const timetableParams = [
			{station: station},
			{limit: 20}
		];

		const timetableQuery = timetableParams.map((item) => {
			return `${Object.keys(item)[0]}=${Object.values(item)[0]}`
		});

		return fetch(`https://transport.opendata.ch/v1/stationboard?${timetableQuery.join('&')}`, 
		{
			method: "GET",
			cache: 'no-cache',
	        
		})
		.then(function(res){ return res.json(); })
		.then(json => {
			if (json) {
				cb(json);
			}
		});
	}



	/*
	The Google Places API Web Service enforces a default limit of 1,000 free requests per 24 hour period, 
	calculated as the sum of client-side and server-side requests. If your app exceeds the initial limit, 
	the app will start failing. You can increase this limit free of charge, up to 150,000 requests per 24 hour period, 
	by enabling billing on the Google API Console to verify your identity. A credit card is required for verification. 
	We ask for your credit card purely to validate your identity. Your card will not be charged for use of the 
	Google Places API Web Service.
	*/

	nearBy(location, type, keyword, radius, cb){

		// this.removeDistanceContent();

		const service = new google.maps.places.PlacesService(this.map);
		 const request = { location, type };
		 if (radius) {                       // caller wants a distance clamp
		   request.radius = radius;          // e.g. 50000 → 50 km
		 } else {
		   request.rankBy = google.maps.places.RankBy.DISTANCE;
		 }
		 if (keyword) request.keyword = keyword;
		
		 service.nearbySearch(request, (results, status, pagination) => {
		   cb(results, status, pagination);
		   if (status === google.maps.places.PlacesServiceStatus.OK &&
		       pagination && pagination.hasNextPage) {
		     setTimeout(() => pagination.nextPage(), 200);
		   }
		 });
	  
	}


	/*
	The standard Google Maps Distance Matrix API supports up to 100,000 elements daily. 
	A project will be restricted to the complimentary 2,500 per-day-limit until you enable billing on the project. 
	Once billing has been enabled, if you exceed 2,500 elements in a day, you will be billed at $0.50 USD / 1000 
	additional elements, up to 100,000 daily.
	*/

	distance(type, origin, destination, cb) {
		const service = new google.maps.DistanceMatrixService();
		return service.getDistanceMatrix({
			origins: [origin],
			destinations: [destination],
			travelMode: type
		}, cb);
	}

	renderDistanceData(icon, response, status, type) {
		let html = '';
		if (status == 'OK') {
			let origins = response.originAddresses;
			let destinations = response.destinationAddresses;

			for (let i = 0; i < origins.length; i++) {
			  let results = response.rows[i].elements;
			  for (let j = 0; j < results.length; j++) {
				let element = results[j];
				// html = ` ${element.distance ? element.distance.text : ''}  ${element.duration ? element.duration.text : ''}`;
				const content = {
					icon,
					distance: element.distance ? this.getFormattedDistance(element.distance.value) : '',
					duration: element.duration ? element.duration.text : ''
				};
				html = Mustache.render(this.templateDistanceResultItem, content);
			  }
			}
		}
		return html;
	}

	getFormattedDistance(distance) {
		let formattedDistance = '';
		let unit = '';
		if (distance) {
			if (distance > 999) {
				// formattedDistance = (distance/1000).toFixed(1);
				formattedDistance = Math.round((distance/1000)*10)/10;
				unit = 'km';
			} else {
				formattedDistance = distance;
				unit = 'm';
			}
		}

		return `${formattedDistance} ${unit}`;
	}

	renderNearbyData(item, index){
		const locationTitle = item.name;
		const locationCoords = item.geometry.location;
		const locationType = item.type;
		const vicinity = item.vicinity

		let marker = this.renderMarker(locationCoords, locationTitle, item.types[0], index+1, this.property, index+1, vicinity);
		this.bounds.extend(marker.getPosition());
		this.markers.push(marker);
		//marker.classList.add('casadistance__result__marker');
		
		let listing = document.createElement('li');
		listing.setAttribute('id', index+1);
		listing.setAttribute('class', 'casadistance__result__listitem');
		// listing.innerHTML = this.createIconWithText(faCircle, this.markerPoiColor, index+1).html
		const formattedDistance = this.getFormattedDistance(item.distance);

		const content = {
			title: `${item.name}, ${formattedDistance}`,
			subtitle: item.formatted_address ? item.formatted_address : item.vicinity,
			number: index+1
		}

		const listingContent = Mustache.render(this.templateListitemContent, content);
		
		/*let h4 = document.createElement('h4');
		h4.setAttribute('class', 'casadistance__listitem__title');
		h4.textContent = `${item.name}, ${item.distance}m`;
		listing.appendChild(h4);

		if(item.type === 'airport'){
			let formattedAddress = document.createElement('span')
			formattedAddress.setAttribute('class', 'casadistance__listitem__subtitle');
			formattedAddress.innerHTML = item.formatted_address;
			h4.appendChild(formattedAddress);
		} else {
			let vicinity = document.createElement('span')
			vicinity.setAttribute('class', 'casadistance__listitem__subtitle');
			vicinity.innerHTML = item.vicinity;
			h4.appendChild(vicinity);
		}*/
		listing.innerHTML = listingContent;
		
		listing.addEventListener('click', (event) => {this.locationOnClickAction(event, locationTitle, locationCoords, locationType, this.property, index+1, vicinity)});
		listing.addEventListener('mouseover', (event) => { this.locationOnMouseOverAction(event, index+1)});
		listing.addEventListener('mouseout', (event) => { this.locationOnMouseOutAction()});
		return listing;
	}

	renderTimetableData(results){
		if(results.stationboard && results.stationboard.length){
			const entries = results.stationboard;
			const timetable = document.createElement('div');
			timetable.classList.add('casadistance__timetable');

			const title = document.createElement('h3');
			title.textContent = this.distanceTimetableTitle;
			timetable.appendChild(title);
			
			const subtitle = document.createElement('span');
			subtitle.textContent = moment().format('LLL'); 
			timetable.appendChild(subtitle);
			
			

			const stopList = document.createElement('ul');

			const listTitle = Mustache.render(this.templateDistanceTimetableListTitle);
			stopList.innerHTML += listTitle;

			stopList.classList.add('casadistance__timetable__list');
			entries.forEach((entry) => {
				
				const content = {
					departure: `${moment(entry.stop.departure).format('LT')}`,
					name: `${entry.name}`,
					to: `${entry.to}`
				};

				const stopListItem = Mustache.render(this.templateDistanceTimetableItem, content);

				// const stopListItem = document.createElement('li');
				// stopListItem.classList.add('casadistance__timetable__listitem');
				
				// const departure = document.createElement('div');
				// departure.classList.add('casadistance__timetable__listitem__departure');

				// departure.innerHTML = `${moment(entry.stop.departure).format('LT')}`;
				// stopListItem.appendChild(departure);

				// const name = document.createElement('div');
				// name.innerHTML = `${entry.name}`;
				// stopListItem.appendChild(name);
				// name.classList.add('casadistance__timetable__listitem__name');
				
				// const to = document.createElement('div');
				// to.innerHTML = `${entry.to}`;
				// stopListItem.appendChild(to);
				// to.classList.add('casadistance__timetable__listitem__to');

				stopList.innerHTML += stopListItem;
			})
			timetable.appendChild(stopList);

			return timetable;
		}

		return false;
	}
}

const app = new Map();
